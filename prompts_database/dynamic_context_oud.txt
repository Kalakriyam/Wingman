# **CONTEXT:**

## Datum en tijd:
{local_date}
{local_time}


## Doel van de huidige conversatie:
Voice UI uitbreiden met de mogelijkheid om prompts op te halen uit het conversatiescript, en ze te bewerken, net zoals nu al met de messages en de conversation summary kan.
{summary}


## Huidige focus:
de code van voice UI begrjipen
dan het paneel uitbreiden waar nu alleen de knop 'push prompt refresh' in staat.
goede aansluiting maken met het conversatiescript.
{current_focus}

---

## Stappenplan verbeteren van de code:
We zijn ergens in de volgende lijst, waar nog niet 'GEDAAN' voor staat:

### ðŸ”¹ **Fase 1: Lokale controle en bewerkbaarheid** 
1. âœ… Refresh trigger vanuit Obsidian
2. âœ… Summary kunnen pushen en bewerken
3. âœ… Live conversatie kunnen bewerken
4. âœ… File agent: bestanden lezen/schrijven
5. ðŸ”œ Events in database i.p.v. losse bestanden
    > bijna klaar, nu nog de prompts in een database
    > bonus/later: een 'sync-agent' die de lokale SQLite databases synchroniseert met de cloud (supabase)


> ðŸ”¸ *Doel: volledige controle over de lokale staat van een gesprek, inclusief bestanden en metadata.*    
---

### ðŸ”¹ **Fase 2: Dynamische placeholders en context**
6. ðŸ”œ Gesprekken kunnen openen, groeperen, bewerken (interface)
7. ðŸ”œ Placeholders in dynamische context kunnen bewerken via Voice UI
8. ðŸ”œ Live system prompt en context kunnen bewerken

> ðŸ”¸ *Doel: dynamische context wordt een levend onderdeel van het gesprek, niet alleen een bestand.*      
---

### ðŸ”¹ **Fase 3: Messaging & Orkestratie**
5. ðŸ”œ Berichten kunnen sturen naar andere agents/crews (getimed of direct)

---

## ðŸ’¡ Waarom deze volgorde beter werkt:

- Je bouwt eerst **lokale bewerkbaarheid** op (fase 1), zodat je alles kunt aanpassen en testen zonder afhankelijk te zijn van messaging of timing.
- Daarna maak je de **context dynamisch** (fase 2), zodat je systeem echt *leeft* tijdens een gesprek.    
- Pas dan ga je naar **inter-agent communicatie en orkestratie** (fase 3), want dan heb je de bouwstenen Ã©n de controle om dat goed te doen.
 

# **RELEVANT CODE SNIPPETS FROM THE AI PROJECT:**


'''python
app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Pas dit aan naar jouw behoeften
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class NoteData(BaseModel):
    title: str
    content: str

class DefaultPrompts(BaseModel):
    system_prompt: str = Field(default="system_prompt.txt")
    dynamic_context: str = Field(default="dynamic_context.txt")

class ConversationState(BaseModel):
    system_prompt_file: str = Field(default="system_prompt.txt")
    dynamic_context_file: str = Field(default="dynamic_context.txt")
    messages_list_file: str
    summary: str = Field(default="")
    timestamp: str
    tags: list = Field(default_factory=list)
    links: list = Field(default_factory=list)

class VoiceUpdateRequest(BaseModel):
    voice_id: str
    voice_name: str

class MessageType(Enum):
    EXCHANGE = "exchange"
    TRIGGER = "trigger"
    ACTION_REQUEST = "action_request"
    TOOL_CALL = "tool_call"
    STATUS_UPDATE = "status_update"

class TriggerType(Enum):
    REFRESH_ALL_PROMPTS = "refresh_all_prompts"
    CLEAR_CONTEXT = "clear_context"
    RESTART_AGENT = "restart_agent"
    PULL_CONVERSATION = "pull_conversation"
    PULL_SUMMARY = "pull_summary"
    # Andere directe triggers zonder payload

class ActionType(Enum):
    REFRESH_SPECIFIC_PROMPT = "refresh_specific_prompt"
    UPDATE_PLACEHOLDERS = "update_placeholders"
    PUSH_SUMMARY = "push_summary"
    PUSH_CONVERSATION = "push_conversation"
    CHANGE_VOICE = "change_voice"
    # Complexere acties met payload

class Message(BaseModel):
    sender: str
    recipient: str
    message_type: MessageType
    trigger_type: Optional[TriggerType]
    action_type: Optional[ActionType]
    payload: Optional[dict[str, Any]]
    # timestamp: str = Field(default_factory=lambda: datetime.now().isoformat())

@app.post('/update')
async def update_content(note: NoteData):
    if note.title and note.content:
        communication_manager.update_obsidian_content(note.title, note.content)
        # return {"message": f"{note.title} succesvol ontvangen"}
        print (f"'{note.title}' succesvol ontvangen")
    
    else:
        raise HTTPException(status_code=400, detail="Titel of inhoud ontbreekt")


@app.post('/message')
async def handle_message(message: Message):
    if message.action_type:
        return communication_manager.handle_action(message)
    elif message.trigger_type:
        return communication_manager.handle_trigger(message)
    

@app.post('/update_voice')
async def update_voice(request: VoiceUpdateRequest):
    update_voice_id(request.voice_id, request.voice_name)
    await generate_model_audio_segments()
    return {"message": f"Stem bijgewerkt naar {request.voice_name}"}

@app.post('/reload_default_prompts')
async def reload_default_prompts(refresh: DefaultPrompts):
    if refresh.system_prompt and refresh.dynamic_context:
        await prompt_manager.reload_default_prompts(refresh.system_prompt, refresh.dynamic_context)
        print ("Verzoek tot reload succesvol ontvangen")
        return {"message": "Verzoek tot reload succesvol ontvangen"}
        
    else:
        raise HTTPException(status_code=400, detail="Bericht incompleet")

class CommunicationManager:
    def __init__(self):
        self.messages: list[dict[str, str]] = []
        self.obsidian_content: str = ""
        self.obsidian_title: str = ""
        self.midi_details: str = ""
        self._lock = asyncio.Lock()
        self.summary: str = ""

    async def handle_action(self, message: Message) -> str:
        async with self._lock:
            if message.action_type == ActionType.PUSH_SUMMARY:
                if message.payload:
                    self.summary = message.payload.get("text", "")
                    print(f"CommunicationManager: Summary updated to: '{self.summary}'")
                    return "summary updated"
                else:
                    print("CommunicationManager: Warning - Received UPDATE_SUMMARY action but payload was missing.")
                    return "warning - payload was missing"

            if message.action_type == ActionType.PUSH_CONVERSATION:
                if message.payload:
                    self.messages = message.payload.get("conversation", [])
                    print("CommunicationManager: Conversation updated ;-)")
                    return "conversation updated"
                else:
                    print("CommunicationManager: Warning - Received UPDATE_CONVERSATION action but payload was missing.")
                    return "warning - payload was missing"

    async def handle_trigger(self, message: Message):
        async with self._lock:
            if message.trigger_type == TriggerType.PULL_CONVERSATION:
                return self.messages
            if message.trigger_type == TriggerType.PULL_SUMMARY:
                return self.summary

    async def get_summary(self) -> str:
        async with self._lock:
            return self.summary

    async def load_summary(self, summary: str) -> None:
        async with self._lock:
            self.summary = summary

    async def add_user_message(self, user_input: str) -> None:
        async with self._lock:
            self.messages.append({"role": "user", "content": user_input})

    async def add_assistant_message(self, assistant_output: str) -> None:
        async with self._lock:
            self.messages.append({"role": "assistant", "content": assistant_output})

    async def get_messages(self) -> list[dict[str, str]]:
        async with self._lock:
            return list(self.messages)

    async def set_messages(self, new_messages: list[dict[str, str]]) -> None:
        async with self._lock:
            self.messages = new_messages

    async def update_obsidian_content(self, title: str, content: str) -> None:
        async with self._lock:
            self.obsidian_title = title
            self.obsidian_content = content
            note_received.set()

    async def update_midi_details(self, midi_details: str) -> None:
        async with self._lock:
            self.midi_details = midi_details

    async def process_incoming_message(self) -> None:
        async with self._lock:
            last_message = next((msg for msg in reversed(self.messages) if msg['role'] in ['user', 'assistant']), None)

            if self.obsidian_content and last_message:
                last_message['content'] += f"\n\n(Obsidian Note: {self.obsidian_title})\n{self.obsidian_content}"
                print(f"Obsidian note added to last message: {self.obsidian_title}")
                self.obsidian_content = ""
                self.obsidian_title = ""

            if self.midi_details and last_message:   
                last_message['content'] += f"\n\nMIDI Details:\n{self.midi_details}"
                print(f"MIDI details added to last message: {self.midi_details}")
                self.midi_details = ""
            # Clipboard
            clipboard_text = pyperclip.paste()
            if clipboard_text.strip() and last_message:
                last_message['content'] += f"\n\n(Pasted clipboard content:)\n{clipboard_text.strip()}"
                pyperclip.copy("")  # Leegmaken
                print("Clipboard content added to last message.")

    def get_messages_sync(self) -> list[dict[str, str]]:
        return self.messages.copy()

    def get_summary_sync(self) -> str:
        return self.summary

    def set_messages_sync(self, new_messages: list[dict[str, str]]) -> None:
        self.messages = new_messages

    def load_summary_sync(self, summary: str) -> None:
        self.summary = summary


class PromptManager:
    def __init__(self):
        self.system_prompt = ""
        self.dynamic_context = []

    async def load_default_prompts(self):
        self.system_prompt = await get_system_prompt("system_prompt.txt")
        self.dynamic_context = await get_dynamic_context("dynamic_context.txt")

    async def reload_default_prompts(self, new_system_prompt: str, new_dynamic_context: str):
        self.system_prompt = await get_system_prompt(f"{new_system_prompt}")
        self.dynamic_context = await get_dynamic_context(f"{new_dynamic_context}")

    def set_default_system_prompt(self, new_system_prompt: str):
        self.system_prompt = new_system_prompt

    def set_default_dynamic_context(self, new_dynamic_context: str):
        self.dynamic_context = new_dynamic_context

    async def get_system_prompt(self):
        return self.system_prompt

    async def get_dynamic_context(self):
        return self.dynamic_context
    
async def main():
    
    os.system("cls")

    client = AsyncOpenAI(api_key=OPENAI_API_KEY)
    
    # Start de taak bij het opstarten
    asyncio.create_task(generate_model_audio_segments())

    whisper_transcriber.setup_key_handlers()  # Set up all key handlers once
    
    await initialize()

    try:
        while not shutdown_event.is_set() and not priority_input_event.is_set():
            user_input = await whisper_transcriber.start()
            await communication_manager.add_user_message(user_input)
            await communication_manager.process_incoming_message()

            print("\n>>>>>>  Thinking...  <<<<<<", end='')
            response_text = await chat_with_llm(client, await communication_manager.get_messages())
            await communication_manager.add_assistant_message(response_text)

    finally:
        logging.warning("Shutdown complete.")
        sys.exit(0)

async def start_uvicorn():
    config = uvicorn.Config(app, host="127.0.0.1", port=5001, log_level="error")
    server = uvicorn.Server(config)
    await server.serve()

# Add this near the end of your file, before the if __name__ == "__main__": block
async def http_session_shutdown():
    if 'global_http_session' in globals() and not global_http_session.closed:
        await global_http_session.close()

if __name__ == "__main__":
    winloop.install()
    whisper_transcriber = WhisperTranscriber()
    communication_manager = CommunicationManager()
    prompt_manager = PromptManager()
    
    async def run_all():
        await initialize_http_session()

        # Set up signal handler at the top level
        # signal.signal(signal.SIGINT, save_conversation)
        load_default_prompts_task = await asyncio.create_task(prompt_manager.load_default_prompts())
        main_task = asyncio.create_task(main())
        

        server = asyncio.create_task(start_uvicorn())
        playback_task = asyncio.create_task(manage_audio_playback())
        # gui_task = asyncio.create_task(gui_loop())
        # first_compound_action_task = asyncio.create_task(first_compound_action())
        tasks_agent_task = asyncio.create_task(tasks_agent())
        obsidian_agent_task = asyncio.create_task(obsidian_agent())
        save_idea_event_task = asyncio.create_task(save_idea_event())
        save_journal_event_task = asyncio.create_task(save_journal_event())
        text_consumer_task = asyncio.create_task(text_processor())
        tool_consumer_task = asyncio.create_task(tool_processor())
        
        # Wait for shutdown_event to be set (by save_conversation)
        await shutdown_event.wait()
        
        # Once shutdown_event is set, cancel all tasks
        server.cancel()
        playback_task.cancel()
        # gui_task.cancel()
        # first_compound_action_task.cancel()
        obsidian_agent_task.cancel()
        save_idea_event_task.cancel()
        save_journal_event_task.cancel()
        tasks_agent_task.cancel()
        main_task.cancel()
        text_consumer_task.cancel()
        tool_consumer_task.cancel()

        await http_session_shutdown()        
        # Wait for cancellation to complete
        await asyncio.gather(load_default_prompts_task, server, playback_task, obsidian_agent_task, tasks_agent_task, main_task, text_consumer_task, tool_consumer_task, return_exceptions=True)
        sys.exit(0)

    asyncio.run(run_all())